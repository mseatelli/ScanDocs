<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2575fc">
    <title>Scanner - D√©tection & Ajustement Auto</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: #333;
            min-height: 100vh;
            padding: 0;
            overflow-x: hidden;
        }
        
        .container {
            width: 100%;
            min-height: 100vh;
            background: white;
            display: flex;
            flex-direction: column;
        }
        
        header {
            background: linear-gradient(90deg, #2575fc, #6a11cb);
            color: white;
            padding: 20px 15px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .app-content {
            flex: 1;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }
        
        .camera-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .camera-container {
            position: relative;
            width: 100%;
            margin: 0 auto;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            background-color: #000;
            aspect-ratio: 4/3;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        
        #canvas, #processing-canvas, #result-canvas {
            display: none;
        }
        
        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .document-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 60%;
            border: 2px dashed rgba(255,255,255,0.7);
            border-radius: 8px;
        }
        
        .camera-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #f0f0f0;
            color: #666;
            text-align: center;
            padding: 20px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 14px 20px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(90deg, #2575fc, #6a11cb);
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(37, 117, 252, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 140px;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .capture-btn {
            background: linear-gradient(90deg, #ff5e7d, #ff9500);
            flex: 2;
            padding: 18px;
            font-size: 1.2rem;
        }
        
        .detect-btn {
            background: linear-gradient(90deg, #00b09b, #96c93d);
        }
        
        .upload-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            text-align: center;
        }
        
        .status {
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
        }
        
        .status.loading {
            background: #fff3cd;
            color: #856404;
        }
        
        .status.success {
            background: #d1edff;
            color: #0c5460;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .scans-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
        }
        
        .scan-item {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
        }
        
        .scan-preview {
            width: 100%;
            height: 120px;
            object-fit: cover;
        }
        
        .edge-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }
        
        .document-outline {
            position: absolute;
            border: 3px solid #00ff88;
            border-radius: 8px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .corner-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #00ff88;
            border-radius: 50%;
            border: 2px solid white;
            cursor: move;
        }

        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            z-index: 10;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .opencv-status {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üì∏ Scanner - D√©tection Auto</h1>
            <p class="subtitle">Bords d√©tect√©s et ajust√©s automatiquement</p>
        </header>
        
        <div class="app-content">
            <div id="opencv-status" class="opencv-status">
                ‚è≥ Chargement OpenCV.js...
            </div>
            
            <div class="camera-section">
                <div class="camera-container">
                    <video id="video" autoplay playsinline></video>
                    <canvas id="canvas"></canvas>
                    <canvas id="processing-canvas"></canvas>
                    <canvas id="result-canvas"></canvas>
                    
                    <div class="processing-overlay" id="processing-overlay">
                        <div class="spinner"></div>
                        <div>D√©tection des bords en cours...</div>
                    </div>
                    
                    <div class="camera-overlay">
                        <div class="document-guide"></div>
                        <div class="edge-preview" id="edge-preview">
                            <div class="document-outline" id="document-outline"></div>
                        </div>
                    </div>
                    
                    <div class="camera-placeholder" id="camera-placeholder">
                        <div>üì∑</div>
                        <p>Chargement en cours...</p>
                    </div>
                </div>
                
                <div class="controls">
                    <button id="start-camera" disabled>
                        <span>üì∑</span> Activer
                    </button>
                    <button id="capture" class="capture-btn" disabled>
                        <span>‚≠ï</span> Capturer
                    </button>
                    <button id="detect-edges" class="detect-btn" disabled>
                        <span>üîç</span> D√©tecter Bords
                    </button>
                    <button id="save-pdf" disabled>
                        <span>üíæ</span> PDF
                    </button>
                </div>
                
                <div class="upload-section">
                    <button id="upload-btn" disabled>
                        <span>üìÅ</span> Importer
                    </button>
                    <input type="file" id="file-input" accept="image/*" style="display: none;">
                </div>
                
                <div id="status" class="status"></div>
            </div>
            
            <div class="scans-section">
                <h2>Documents Scann√©s</h2>
                <div id="scans-container" class="scans-container">
                    <div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #666;">
                        Aucun document scann√©
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let cv = null;
        let stream = null;
        let capturedImage = null;
        let correctedImage = null;
        let scans = JSON.parse(localStorage.getItem('documentScans')) || [];
        let detectedCorners = null;

        // √âl√©ments DOM
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const processingCanvas = document.getElementById('processing-canvas');
        const resultCanvas = document.getElementById('result-canvas');
        const ctx = canvas.getContext('2d');
        const processingCtx = processingCanvas.getContext('2d');
        const resultCtx = resultCanvas.getContext('2d');

        // OpenCV ready
        function onOpenCvReady() {
            cv = window.cv;
            document.getElementById('opencv-status').innerHTML = '‚úÖ OpenCV.js charg√© !';
            document.getElementById('start-camera').disabled = false;
            document.getElementById('upload-btn').disabled = false;
            document.getElementById('camera-placeholder').innerHTML = '<div>üì∑</div><p>Appuyez sur "Activer la cam√©ra"</p>';
            showStatus("OpenCV pr√™t - D√©tection active", "success");
        }

        // D√âTECTION ET AJUSTEMENT DES BORDS
        function detectAndAdjustEdges() {
            if (!capturedImage || !cv) return;
            
            const processingOverlay = document.getElementById('processing-overlay');
            processingOverlay.style.display = 'flex';
            showStatus("üîç D√©tection et ajustement des bords...", "loading");
            
            setTimeout(() => {
                try {
                    const img = new Image();
                    img.onload = function() {
                        // Pr√©parer les canvas
                        const width = img.width;
                        const height = img.height;
                        canvas.width = processingCanvas.width = resultCanvas.width = width;
                        canvas.height = processingCanvas.height = resultCanvas.height = height;
                        
                        ctx.drawImage(img, 0, 0);
                        processingCtx.drawImage(img, 0, 0);
                        
                        // D√©tection OpenCV
                        let src = cv.imread(processingCanvas);
                        let detected = detectDocumentCorners(src);
                        
                        if (detected && detected.corners) {
                            detectedCorners = detected.corners;
                            
                            // Afficher le contour d√©tect√©
                            showDetectedCorners(detected.corners, width, height);
                            
                            // Appliquer la correction perspective
                            applyPerspectiveCorrection(src, detected.corners, width, height);
                            
                            showStatus("‚úÖ Bords d√©tect√©s et ajust√©s !", "success");
                        } else {
                            showStatus("‚ùå Aucun document d√©tect√©", "error");
                        }
                        
                        src.delete();
                        processingOverlay.style.display = 'none';
                    };
                    img.src = capturedImage;
                    
                } catch (error) {
                    console.error('Erreur d√©tection:', error);
                    showStatus("‚ùå Erreur lors de la d√©tection", "error");
                    document.getElementById('processing-overlay').style.display = 'none';
                }
            }, 100);
        }

        function detectDocumentCorners(src) {
            try {
                // 1. Conversion en niveaux de gris
                let gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // 2. Flou gaussien
                let blurred = new cv.Mat();
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                
                // 3. D√©tection des bords Canny
                let edges = new cv.Mat();
                cv.Canny(blurred, edges, 50, 150);
                
                // 4. Dilatation pour fermer les contours
                let dilated = new cv.Mat();
                let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
                cv.dilate(edges, dilated, kernel);
                
                // 5. Trouver les contours
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(dilated, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                
                // 6. Chercher le meilleur contour de document
                let bestContour = null;
                let bestScore = 0;
                
                for (let i = 0; i < contours.size(); ++i) {
                    let contour = contours.get(i);
                    let area = cv.contourArea(contour);
                    
                    // Ignorer les trop petits contours
                    if (area < (src.rows * src.cols * 0.1)) {
                        contour.delete();
                        continue;
                    }
                    
                    // Approximation polygonale
                    let epsilon = 0.02 * cv.arcLength(contour, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(contour, approx, epsilon, true);
                    
                    // Score bas√© sur l'aire et la r√©gularit√©
                    let score = area;
                    
                    // Bonus pour les quadrilat√®res
                    if (approx.rows === 4) {
                        score *= 1.5;
                        
                        // V√©rifier la convexit√©
                        let hull = new cv.Mat();
                        cv.convexHull(approx, hull);
                        if (hull.rows === 4) {
                            score *= 1.2;
                        }
                        hull.delete();
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        if (bestContour) bestContour.delete();
                        bestContour = approx;
                    } else {
                        approx.delete();
                    }
                    
                    contour.delete();
                }
                
                let result = null;
                if (bestContour && bestContour.rows === 4) {
                    // Extraire les coins
                    let corners = [];
                    for (let i = 0; i < 4; i++) {
                        let x = bestContour.data32S[i * 2];
                        let y = bestContour.data32S[i * 2 + 1];
                        corners.push({ x: x, y: y });
                    }
                    
                    // Trier les coins : haut-gauche, haut-droit, bas-droit, bas-gauche
                    corners.sort((a, b) => a.y - b.y);
                    let top = corners.slice(0, 2).sort((a, b) => a.x - b.x);
                    let bottom = corners.slice(2, 4).sort((a, b) => a.x - b.x);
                    
                    result = {
                        corners: [top[0], top[1], bottom[1], bottom[0]]
                    };
                }
                
                // Nettoyer la m√©moire
                gray.delete(); blurred.delete(); edges.delete(); 
                dilated.delete(); kernel.delete(); contours.delete(); 
                hierarchy.delete();
                if (bestContour) bestContour.delete();
                
                return result;
                
            } catch (error) {
                console.error('Erreur d√©tection coins:', error);
                return null;
            }
        }

        function showDetectedCorners(corners, imgWidth, imgHeight) {
            const container = document.querySelector('.camera-container');
            const containerRect = container.getBoundingClientRect();
            
            const scaleX = containerRect.width / imgWidth;
            const scaleY = containerRect.height / imgHeight;
            
            // Calculer le rectangle englobant
            const minX = Math.min(...corners.map(p => p.x));
            const maxX = Math.max(...corners.map(p => p.x));
            const minY = Math.min(...corners.map(p => p.y));
            const maxY = Math.max(...corners.map(p => p.y));
            
            const outline = document.getElementById('document-outline');
            outline.style.left = (minX * scaleX) + 'px';
            outline.style.top = (minY * scaleY) + 'px';
            outline.style.width = ((maxX - minX) * scaleX) + 'px';
            outline.style.height = ((maxY - minY) * scaleY) + 'px';
            
            document.getElementById('edge-preview').style.display = 'block';
            
            // Animation
            outline.style.transform = 'scale(0.95)';
            outline.style.opacity = '0';
            setTimeout(() => {
                outline.style.transition = 'all 0.4s ease';
                outline.style.transform = 'scale(1)';
                outline.style.opacity = '1';
            }, 100);
        }

        function applyPerspectiveCorrection(src, corners, originalWidth, originalHeight) {
            try {
                // Points source (coins d√©tect√©s)
                let srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    corners[0].x, corners[0].y,
                    corners[1].x, corners[1].y,
                    corners[2].x, corners[2].y,
                    corners[3].x, corners[3].y
                ]);
                
                // Points destination (rectangle droit)
                const outputWidth = originalWidth;
                const outputHeight = originalHeight;
                
                let dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    0, 0,
                    outputWidth, 0,
                    outputWidth, outputHeight,
                    0, outputHeight
                ]);
                
                // Calculer la matrice de transformation perspective
                let transform = cv.getPerspectiveTransform(srcPoints, dstPoints);
                
                // Appliquer la transformation
                let dst = new cv.Mat();
                cv.warpPerspective(src, dst, transform, new cv.Size(outputWidth, outputHeight));
                
                // Afficher le r√©sultat
                cv.imshow(resultCanvas, dst);
                correctedImage = resultCanvas.toDataURL('image/jpeg', 0.9);
                
                // Mettre √† jour l'image captur√©e avec la version corrig√©e
                capturedImage = correctedImage;
                
                // Nettoyer
                srcPoints.delete(); dstPoints.delete(); transform.delete(); dst.delete();
                
            } catch (error) {
                console.error('Erreur correction perspective:', error);
            }
        }

        // Gestion des √©v√©nements
        document.addEventListener('DOMContentLoaded', function() {
            updateScansDisplay();
            setupEventListeners();
        });

        function setupEventListeners() {
            document.getElementById('start-camera').addEventListener('click', startCamera);
            document.getElementById('capture').addEventListener('click', captureImage);
            document.getElementById('detect-edges').addEventListener('click', detectAndAdjustEdges);
            document.getElementById('save-pdf').addEventListener('click', saveAsPDF);
            document.getElementById('upload-btn').addEventListener('click', () => document.getElementById('file-input').click());
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
        }

        async function startCamera() {
            try {
                showStatus("Activation cam√©ra...", "loading");
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                video.srcObject = stream;
                document.getElementById('camera-placeholder').style.display = 'none';
                document.getElementById('start-camera').disabled = true;
                document.getElementById('capture').disabled = false;
                showStatus("‚úÖ Cam√©ra activ√©e", "success");
                
            } catch (error) {
                showStatus("‚ùå Erreur cam√©ra", "error");
            }
        }

        function captureImage() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            capturedImage = canvas.toDataURL('image/jpeg', 0.9);
            document.getElementById('detect-edges').disabled = false;
            document.getElementById('save-pdf').disabled = false;
            document.getElementById('edge-preview').style.display = 'none';
            showStatus("‚úÖ Image captur√©e", "success");
        }

        function saveAsPDF() {
            if (!capturedImage) return;
            
            showStatus("üìÑ G√©n√©ration PDF...", "loading");
            
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF();
            const imgProps = pdf.getImageProperties(capturedImage);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
            
            pdf.addImage(capturedImage, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            
            const filename = `document-${new Date().toISOString().replace(/[:.]/g, '-')}.pdf`;
            pdf.save(filename);
            
            scans.unshift({
                id: Date.now(),
                image: capturedImage,
                filename: filename,
                date: new Date().toLocaleString('fr-FR')
            });
            
            localStorage.setItem('documentScans', JSON.stringify(scans));
            updateScansDisplay();
            showStatus("‚úÖ PDF g√©n√©r√©", "success");
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                capturedImage = e.target.result;
                document.getElementById('detect-edges').disabled = false;
                document.getElementById('save-pdf').disabled = false;
                document.getElementById('edge-preview').style.display = 'none';
                showStatus("‚úÖ Image import√©e", "success");
            };
            reader.readAsDataURL(file);
        }

        function updateScansDisplay() {
            const container = document.getElementById('scans-container');
            if (scans.length === 0) {
                container.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;color:#666">Aucun document</div>';
                return;
            }
            
            container.innerHTML = scans.map(scan => `
                <div class="scan-item">
                    <img src="${scan.image}" class="scan-preview">
                    <div style="padding:10px;display:flex;gap:5px;">
                        <button class="action-btn download-btn" onclick="downloadScan(${scan.id})" style="flex:1;padding:8px;background:#00b09b;color:white;border:none;border-radius:6px;">‚¨áÔ∏è</button>
                        <button class="action-btn delete-btn" onclick="deleteScan(${scan.id})" style="flex:1;padding:8px;background:#ff5e7d;color:white;border:none;border-radius:6px;">üóëÔ∏è</button>
                    </div>
                    <div style="padding:8px;font-size:0.7rem;color:#666;text-align:center">${scan.date.split(' ')[0]}</div>
                </div>
            `).join('');
        }

        function downloadScan(id) {
            const scan = scans.find(s => s.id === id);
            if (!scan) return;
            
            const link = document.createElement('a');
            link.href = scan.image;
            link.download = scan.filename.replace('.pdf', '.jpg');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function deleteScan(id) {
            if (confirm("Supprimer ce document ?")) {
                scans = scans.filter(s => s.id !== id);
                localStorage.setItem('documentScans', JSON.stringify(scans));
                updateScansDisplay();
                showStatus("Document supprim√©", "success");
            }
        }

        function showStatus(message, type = '') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }

        // Nettoyage
        window.addEventListener('beforeunload', () => {
            if (stream) stream.getTracks().forEach(track => track.stop());
        });
    </script>
</body>
</html>